---
title: 操作系统 - 内存管理
date: 2021-02-21 17:44:28
categories: 
- OS
- 内存管理
tags: [OS,内存管理]
keywords: [OS,内存管理]
---

OS内存管理
<!---more--->
## 地址空间
### 逻辑地址空间
一个程序拥有的地址空间；

### 物理地址空间
实际分配到硬件的地址空间


## 地址分配

### 内存分配算法

1. 首次适配：速度快；但容易产生碎片；
2. 最优适配：避免产生外部碎片；但需要排序，且容易产生许多无法使用的小碎片。
3. 最差适配：占用大分区，如果来了个大的程序可能无法分配。

以上，造成内存的利用率低，内存地址连续；


### 动态内存分配

- 优点：地址非连续，内存利用率高，支持动态加载和动态链接，支持共享代码和数据；
- 缺点：需要虚拟地址和物理地址的转换。

### 分段式管理

将程序的堆、栈、代码段、数据段等，分配到不同的物理地址空间上。

映射方法：虚拟地址：段号+偏移 -> 物理地址：起点+长度

目前多用分页机制管理。

### 分页式管理

将虚拟内存划分成相同大小的页，将物理内存划分成固定大小的帧。

映射方式：二元组(f,o)

帧号f，共F位； 帧内偏移o，共S位。

物理地址空间内，有2^F个帧，每帧大小2^S

物理地址 = 2^S * f + o 。

#### 地址转换

1. CPU发出寻址请求，往页表寻址；
2. 将页号作为索引，找到页号对应的帧号；
3. 页偏移和帧偏移大小一样。
4. 页表在OS进行内存初始化的时候建立。

#### 页表

- 页表标志位：

   1. 脏位：用于页面置换时是否需要写入判断；
   2. 缺页异常位：用于页面置换时缺页异常判断；
   3. clock置换算法位等；
   4. 可读可写位等；

- 页表的问题：

  - 性能问题：
    1. 页表可能很大；
    2. 访问内存要2次；

- 解决办法：
  1. 多级页表，页表存下一级页表的目录项；
  2. TLB，缓存最近使用过的页在CPU Cache中。



### 段页式管理

内存分页，进程分段，段内分页。

每个进程建一个段表，每个段表内分配一个页表。



## 虚拟内存

### 为什么需要虚拟内存

计算机在多程序的运行下，可能会出现内存不够用的情况；

这时候就需要把数据以更小的粒度导入到内存中来，充分利用内存空间。

- 原理：局部性原理。

  - 时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下一次访问都集中在一个较短时期内。

  - 空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内。


- 特征：

  1. 大用户空间：仿佛一个程序能使用整个位数的地址空间；
  2. 部分交换： 不用整个程序换出；
  3. 不连续：虚拟内存换出时候，再换进，造成不连续。

### 虚拟页式管理

1. 当一个用户程序要调入内存运行时，不是将该程序的所以页面都装入内存，而是只装入部分的页面，就可以启动程序运行。
2. 在运行的过程中，如果发现要运行的程序或要访问数据不在内存，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应的页面调入内存，使得该程序能够继续运行。

- 页表标志位：

  1. 驻留位：是否正在内存中；
  2. 保护位：允许该页做什么类型的访问；
  3. 修改位：回收时确定是否被修改过，如果修改过需要写回硬盘；
  4. 访问位：访问标志，用于页面置换算法。

### 缺页中断

1. 缺页，有空闲内存，将要访问的页p调入内存；修改页表项对应的数据；
2. 缺页，没有空闲内存，使用页面置换算法，将暂时不用的页面换出；修改页表驻留位，将要访问的页面p装入，然后继续修改页表项。

最后重新执行中断前的指令。


## 页面置换算法

### 先进先出FIFO：

链表或队列实现，性能较差，调出的可能是频繁访问的页面。

### 最近最久未使用LRU：

根据程序的局部性原理，将最久未使用的页面更换。

### 最不常用LFU：

计算最近一段时间内使用频次最少的页面，需要有计数器。

### CLOCK算法：

环形链表，指针指向最老页面；缺页中断时，如果访问位为0，换出；否则将访问位置0，然后移动指针到下一个访问位为0的最老页面。

### 二次机会法：

类似clock算法，但是将脏位纳入考虑范围。只有脏位和访问位都为0才换出。

## Belady现象：

分配物理页越多，缺页越高。

原因：FIFO换出的特征与内存动态访问特征不一致，有可能换出去的是常用的页面。


## 全局页面置换算法：

工作集： 进程正在使用的逻辑页面
常驻集： 进程驻留在内存中的逻辑页面

工作集替换：替换不在工作集中的页面

- 缺页率页面置换算法：

动态分配常驻集大小：如果缺页率变高，就分配更多的物理页面；否则分配少一些。

- 抖动问题：

某一进程分配物理页太少，频繁缺页中断；

随着进程的增多，分配给每个进程的物理页也会变少。


## Linux内核内存管理相关：

### 进程地址空间
使用内存描述符来表示进程的地址空间（mm_struct），其字段包括：

1. vm_area_struct类型的： 虚拟内存区域， （链表，红黑树）， 一个易于表示，一个便于查找。
2. 页全局目录；
3. 引用计数；
4. 代码段、数据段、堆的首尾地址，栈的首地址。
5. 锁、信号量等。

### 虚拟内存区域(VMA)
VMA常用来描述指定地址空间内连续区间上的、拥有相同访问属性的一个独立内存范围。
字段包括：区间起始位置、区间结束位置、mm_struct、访问控制权限等。

注意如果是两个不同的进程映射到同一个虚拟地址空间，他们的vm_area_struct会分别有一个；单如果共享一个地址空间，那么会共享这个VMA。


### 页

内核将物理页作为内存管理的基本单位，MMU进行内存管理和将虚拟地址转换为物理地址，同时管理页表。

内核用

```C
struct page{
    void* virtual //虚拟地址
    atomic_t count //引用次数，为0时用于回收
    struct list_head //LRU用于

}

```

表示物理页。

### 区

由于硬件限制，有些页存在于内存特定区域上，用作不同的用途。

linux在x86上分为三个区，DMA/NORMAL/HIGHMEM

DMA区域用于DMA访问（直接内存访问，无需映射）

NORMAL：正常寻址的页面

HIGHMEM：动态映射的页面。

在Linux中用

```C

struct zone{

}
```
表示。

### 分配页的函数

1. kmalloc()，需要连续的物理页；
2. 高端内存分配：alloc_pages()，得到一个page struct；要得到真正的地址空间，要调用kmap()；
3. vmalloc() 不需要连续的物理页，只是虚拟地址是连续的。
4. 通过slab进行对象的高速缓存。